decl
	// For global variables
	stack_head_0,
	stack_head_1,
	stack_head_2,
	stack_head_p,  // precise bit

	stack_count_0,
	stack_count_1,
	stack_count_2,
	stack_count_p,   // precise bit

	stack_value0_0,
	stack_value0_1,
	stack_value0_2,
	stack_value0_p,   // precise bit

	stack_value1_0,
	stack_value1_1,
	stack_value1_2,
	stack_value1_p,   // precise bit

	stack_value2_0,
	stack_value2_1,
	stack_value2_2,
	stack_value2_p,   // precise bit

	stack_next0_0,
	stack_next0_1,
	stack_next0_2,
	stack_next0_p,   // precise bit

	stack_next1_0,
	stack_next1_1,
	stack_next1_2,
	stack_next1_p,   // precise bit

	stack_next2_0,
	stack_next2_1,
	stack_next2_2,
	stack_next2_p,   // precise bit
	atomic
;


void init ()
begin
decl at;
	// set all precise bit to 1
	stack_head_p, stack_count_p, stack_value0_p, stack_value1_p, stack_value2_p, stack_next0_p, stack_next1_p, stack_next2_p := T, T, T, T, T, T, T, T;

	stack_count_0, stack_count_1, stack_count_2 := F, T, T;   // stack_count = 3
	stack_head_0, stack_head_1, stack_head_2 := F, F, F;    // stack_head = 0
	stack_next0_0, stack_next0_1, stack_next0_2 := F, F, T;   // next0 = 1
	stack_next1_0, stack_next1_1, stack_next1_2 := F, T, F;  // next1 = 2
	stack_next2_0, stack_next2_1, stack_next2_2 := F, T, F;   // next2 = -1
	endinit: skip;
end

void thread0 ()
begin
decl at;
decl ifcond;
decl elem_0, elem_1, elem_2, elem_p;
decl head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;
decl head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p;
decl next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
decl head1Push_0, head1Push_1, head1Push_2, head1Push_p;

	elem_p, head1Pop_p, head2Pop_p, head1Push_p := T, T, T, T;

	// for (i := 0; i < 2; i++)
	/////////////////////////////////////////////////////////////////////////////////////////
	// First loop of thread
	/////////////////////////////////////////////////////////////////////////////////////////
		// While loop unroll 1
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
                     atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;

				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
			        head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
                	atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
                			atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
                			atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
                if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
                	atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop1_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop1: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
// While loop unroll 2
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, stack_next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, stack_next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop2_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop2: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
// While loop unroll 3
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop3_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop3: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
	Exit_thread_while1: skip;

	atomic, at := T, T;
	// stack.array[elem].Value == 0;
	if (!elem_p) then
		if (*) then
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, F, T;
		else
			if (*) then
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, F, T;
			else
				stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, F, T;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then    // elem := 0
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, F, T;
		else
			if (!elem_0 & !elem_1 & elem_2) then   // elem := 1
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, F, T;
			else
				if (!elem_0 & elem_1 & !elem_2) then   // elem := 2
					stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, F, T;
				else
					if (*) then
						stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, F, T;
					else
						if (*) then
							stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, F, T;
						else
							stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, F, T;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;

	atomic, at := F, F;
	///////////////////////////////////////
	///  ASSERTION
	///////////////////////////////////////
	atomic, at := T, T;
	// assert(stack.array[elem].Value == 0);
	if (!elem_p) then
		OF_ERROR: skip;
	else
		if (!elem_0 & !elem_1 & !elem_2) then
			if (!(!stack_value0_0 & !stack_value0_1 & !stack_value0_2)) then
				SLIC_ERROR: skip;
			fi;
		else
			if (!elem_0 & !elem_1 & elem_2) then
				if (!(!stack_value1_0 & !stack_value1_1 & !stack_value1_2)) then
					SLIC_ERROR: skip;
				fi;
			else
				if (!elem_0 & elem_1 & !elem_2) then
					if(!(!stack_value2_0 & !stack_value2_1 & !stack_value2_2)) then
						SLIC_ERROR: skip;
					fi;
				else
					OF2_ERROR: skip;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;

	// Push(elem);
	atomic, at := T, T;
	// int head1 := __VERIFIER_atomic_load(&stack.head);
	head1Push_0, head1Push_1, head1Push_2, head1Push_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
	atomic, at := F, F;

	// Unroll dowhile 1
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	// Unroll dowhile 2
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	// Unroll dowhile 3
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	assume(F);
	Exit_push1_dowhile: skip;

	atomic, at := T, T;
	// __VERIFIER_atomic_fetch_add(&stack.count, 1);
	if (!stack_count_p) then
		stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
	else
		if (!stack_count_0 & !stack_count_1 & !stack_count_2) then    // stack_count = 0
			stack_count_0, stack_count_1, stack_count_2 := F, F, T;  // stack_count = 1
		else
			if (!stack_count_0 & !stack_count_1 & stack_count_2) then  // stack_count = 1
				stack_count_0, stack_count_1, stack_count_2 := F, T, F;   // stack_count = 2
			else
				if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
					stack_count_0, stack_count_1, stack_count_2 := F, T, T;   // stack_count = 3
				else
					stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;


	/////////////////////////////////////////////////////////////////////////////////////////
	// Second loop thread
	/////////////////////////////////////////////////////////////////////////////////////////
		// While loop unroll 1
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop4_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop4: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
// While loop unroll 2
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop5_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop5: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
// While loop unroll 3
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop6_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop6: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
	Exit_thread_while2: skip;

	atomic, at := T, T;
	// stack.array[elem].Value == 0;
	if (!elem_p) then
		if (*) then
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, F, T;
		else
			if (*) then
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, F, T;
			else
				stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, F, T;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then    // elem := 0
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, F, T;
		else
			if (!elem_0 & !elem_1 & elem_2) then   // elem := 1
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, F, T;
			else
				if (!elem_0 & elem_1 & !elem_2) then   // elem := 2
					stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, F, T;
				else
					if (*) then
						stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, F, T;
					else
						if (*) then
							stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, F, T;
						else
							stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, F, T;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	///////////////////////////////////////
	///  ASSERTION
	///////////////////////////////////////
	// assert(stack.array[elem].Value == 0);
	if (!elem_p) then
		OF_ERROR: skip;
	else
		if (!elem_0 & !elem_1 & !elem_2) then
			if (!(!stack_value0_0 & !stack_value0_1 & !stack_value0_2)) then
				SLIC_ERROR: skip;
			fi;
		else
			if (!elem_0 & !elem_1 & elem_2) then
				if (!(!stack_value1_0 & !stack_value1_1 & !stack_value1_2)) then
					SLIC_ERROR: skip;
				fi;
			else
				if (!elem_0 & elem_1 & !elem_2) then
					if(!(!stack_value2_0 & !stack_value2_1 & !stack_value2_2)) then
						SLIC_ERROR: skip;
					fi;
				else
					OF2_ERROR: skip;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;

	// Push(elem);
	atomic, at := T, T;
	// int head1 := __VERIFIER_atomic_load(&stack.head);
	head1Push_0, head1Push_1, head1Push_2, head1Push_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
	atomic, at := F, F;

	// Unroll dowhile 1
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	// Unroll dowhile 2
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	// Unroll dowhile 3
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	assume(F);
	Exit_push2_dowhile: skip;

	atomic, at := T, T;
	// __VERIFIER_atomic_fetch_add(&stack.count, 1);
	if (!stack_count_p) then
		stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
	else
		if (!stack_count_0 & !stack_count_1 & !stack_count_2) then    // stack_count = 0
			stack_count_0, stack_count_1, stack_count_2 := F, F, T;  // stack_count = 1
		else
			if (!stack_count_0 & !stack_count_1 & stack_count_2) then  // stack_count = 1
				stack_count_0, stack_count_1, stack_count_2 := F, T, F;   // stack_count = 2
			else
				if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
					stack_count_0, stack_count_1, stack_count_2 := F, T, T;   // stack_count = 3
				else
					stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
end










void thread1 ()
begin
decl at;
decl ifcond;
decl elem_0, elem_1, elem_2, elem_p;
decl head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;
decl head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p;
decl next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
decl head1Push_0, head1Push_1, head1Push_2, head1Push_p;

	elem_p, head1Pop_p, head2Pop_p, head1Push_p := T, T, T, T;

	// for (i := 0; i < 2; i++)
	/////////////////////////////////////////////////////////////////////////////////////////
	// First loop of thread
	/////////////////////////////////////////////////////////////////////////////////////////
		// While loop unroll 1
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;

				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop1_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop1: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
// While loop unroll 2
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, stack_next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, stack_next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop2_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop2: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
// While loop unroll 3
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop3_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop3: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
	Exit_thread_while1: skip;

	atomic, at := T, T;
	// stack.array[elem].Value == 1;
	if (!elem_p) then
		if (*) then
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, T, T;
		else
			if (*) then
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, T, T;
			else
				stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, T, T;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then    // elem := 0
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, T, T;
		else
			if (!elem_0 & !elem_1 & elem_2) then   // elem := 1
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, T, T;
			else
				if (!elem_0 & elem_1 & !elem_2) then   // elem := 2
					stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, T, T;
				else
					if (*) then
						stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, T, T;
					else
						if (*) then
							stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, T, T;
						else
							stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, T, T;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;

	atomic, at := F, F;
	///////////////////////////////////////
	///  ASSERTION
	///////////////////////////////////////
	atomic, at := T, T;
	// assert(stack.array[elem].Value == 1);
	if (!elem_p) then
		OF_ERROR: skip;
	else
		if (!elem_0 & !elem_1 & !elem_2) then
			if (!(!stack_value0_0 & !stack_value0_1 & stack_value0_2)) then
				SLIC_ERROR: skip;
			fi;
		else
			if (!elem_0 & !elem_1 & elem_2) then
				if (!(!stack_value1_0 & !stack_value1_1 & stack_value1_2)) then
					SLIC_ERROR: skip;
				fi;
			else
				if (!elem_0 & elem_1 & !elem_2) then
					if(!(!stack_value2_0 & !stack_value2_1 & stack_value2_2)) then
						SLIC_ERROR: skip;
					fi;
				else
					OF2_ERROR: skip;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;

	// Push(elem);
	atomic, at := T, T;
	// int head1 := __VERIFIER_atomic_load(&stack.head);
	head1Push_0, head1Push_1, head1Push_2, head1Push_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
	atomic, at := F, F;

	// Unroll dowhile 1
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	// Unroll dowhile 2
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	// Unroll dowhile 3
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	assume(F);
	Exit_push1_dowhile: skip;

	atomic, at := T, T;
	// __VERIFIER_atomic_fetch_add(&stack.count, 1);
	if (!stack_count_p) then
		stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
	else
		if (!stack_count_0 & !stack_count_1 & !stack_count_2) then    // stack_count = 0
			stack_count_0, stack_count_1, stack_count_2 := F, F, T;  // stack_count = 1
		else
			if (!stack_count_0 & !stack_count_1 & stack_count_2) then  // stack_count = 1
				stack_count_0, stack_count_1, stack_count_2 := F, T, F;   // stack_count = 2
			else
				if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
					stack_count_0, stack_count_1, stack_count_2 := F, T, T;   // stack_count = 3
				else
					stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;


	/////////////////////////////////////////////////////////////////////////////////////////
	// Second loop thread
	/////////////////////////////////////////////////////////////////////////////////////////
		// While loop unroll 1
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop4_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop4: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
// While loop unroll 2
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop5_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop5: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
// While loop unroll 3
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop6_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop6: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
	Exit_thread_while2: skip;

	atomic, at := T, T;
	// stack.array[elem].Value == 0;
	if (!elem_p) then
		if (*) then
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, T, T;
		else
			if (*) then
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, T, T;
			else
				stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, T, T;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then    // elem := 0
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, T, T;
		else
			if (!elem_0 & !elem_1 & elem_2) then   // elem := 1
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, T, T;
			else
				if (!elem_0 & elem_1 & !elem_2) then   // elem := 2
					stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, T, T;
				else
					if (*) then
						stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, F, T, T;
					else
						if (*) then
							stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, F, T, T;
						else
							stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, F, T, T;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	///////////////////////////////////////
	///  ASSERTION
	///////////////////////////////////////
	// assert(stack.array[elem].Value == 0);
	if (!elem_p) then
		OF_ERROR: skip;
	else
		if (!elem_0 & !elem_1 & !elem_2) then
			if (!(!stack_value0_0 & !stack_value0_1 & stack_value0_2)) then
				SLIC_ERROR: skip;
			fi;
		else
			if (!elem_0 & !elem_1 & elem_2) then
				if (!(!stack_value1_0 & !stack_value1_1 & stack_value1_2)) then
					SLIC_ERROR: skip;
				fi;
			else
				if (!elem_0 & elem_1 & !elem_2) then
					if(!(!stack_value2_0 & !stack_value2_1 & stack_value2_2)) then
						SLIC_ERROR: skip;
					fi;
				else
					OF2_ERROR: skip;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;

	// Push(elem);
	atomic, at := T, T;
	// int head1 := __VERIFIER_atomic_load(&stack.head);
	head1Push_0, head1Push_1, head1Push_2, head1Push_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
	atomic, at := F, F;

	// Unroll dowhile 1
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	// Unroll dowhile 2
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	// Unroll dowhile 3
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	assume(F);
	Exit_push2_dowhile: skip;

	atomic, at := T, T;
	// __VERIFIER_atomic_fetch_add(&stack.count, 1);
	if (!stack_count_p) then
		stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
	else
		if (!stack_count_0 & !stack_count_1 & !stack_count_2) then    // stack_count = 0
			stack_count_0, stack_count_1, stack_count_2 := F, F, T;  // stack_count = 1
		else
			if (!stack_count_0 & !stack_count_1 & stack_count_2) then  // stack_count = 1
				stack_count_0, stack_count_1, stack_count_2 := F, T, F;   // stack_count = 2
			else
				if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
					stack_count_0, stack_count_1, stack_count_2 := F, T, T;   // stack_count = 3
				else
					stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
end










void thread2 ()
begin
decl at;
decl ifcond;
decl elem_0, elem_1, elem_2, elem_p;
decl head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;
decl head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p;
decl next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
decl head1Push_0, head1Push_1, head1Push_2, head1Push_p;

	elem_p, head1Pop_p, head2Pop_p, head1Push_p := T, T, T, T;

	// for (i := 0; i < 2; i++)
	/////////////////////////////////////////////////////////////////////////////////////////
	// First loop of thread
	/////////////////////////////////////////////////////////////////////////////////////////
		// While loop unroll 1
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;

				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop1_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop1;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop1_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop1: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
// While loop unroll 2
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, stack_next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop2_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop2;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, stack_next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop2_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop2: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
// While loop unroll 3
		if (F) then
			goto Exit_thread_while1;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop3_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop3;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop3_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop3: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while1;    // break while
			fi;
		fi;
	Exit_thread_while1: skip;

	atomic, at := T, T;
	// stack.array[elem].Value == 2;
	if (!elem_p) then
		if (*) then
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, T, F, T;
		else
			if (*) then
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, T, F, T;
			else
				stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, T, F, T;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then    // elem := 0
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, T, F, T;
		else
			if (!elem_0 & !elem_1 & elem_2) then   // elem := 1
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, T, F, T;
			else
				if (!elem_0 & elem_1 & !elem_2) then   // elem := 2
					stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, T, F, T;
				else
					if (*) then
						stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, T, F, T;
					else
						if (*) then
							stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, T, F, T;
						else
							stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, T, F, T;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;

	atomic, at := F, F;
	///////////////////////////////////////
	///  ASSERTION
	///////////////////////////////////////
	atomic, at := T, T;
	// assert(stack.array[elem].Value == 0);
	if (!elem_p) then
		OF_ERROR: skip;
	else
		if (!elem_0 & !elem_1 & !elem_2) then
			if (!(!stack_value0_0 & stack_value0_1 & !stack_value0_2)) then
				SLIC_ERROR: skip;
			fi;
		else
			if (!elem_0 & !elem_1 & elem_2) then
				if (!(!stack_value1_0 & stack_value1_1 & !stack_value1_2)) then
					SLIC_ERROR: skip;
				fi;
			else
				if (!elem_0 & elem_1 & !elem_2) then
					if(!(!stack_value2_0 & stack_value2_1 & !stack_value2_2)) then
						SLIC_ERROR: skip;
					fi;
				else
					OF2_ERROR: skip;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;

	// Push(elem);
	atomic, at := T, T;
	// int head1 := __VERIFIER_atomic_load(&stack.head);
	head1Push_0, head1Push_1, head1Push_2, head1Push_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
	atomic, at := F, F;

	// Unroll dowhile 1
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	// Unroll dowhile 2
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	// Unroll dowhile 3
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push1_dowhile;
	fi;

	assume(F);
	Exit_push1_dowhile: skip;

	atomic, at := T, T;
	// __VERIFIER_atomic_fetch_add(&stack.count, 1);
	if (!stack_count_p) then
		stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
	else
		if (!stack_count_0 & !stack_count_1 & !stack_count_2) then    // stack_count = 0
			stack_count_0, stack_count_1, stack_count_2 := F, F, T;  // stack_count = 1
		else
			if (!stack_count_0 & !stack_count_1 & stack_count_2) then  // stack_count = 1
				stack_count_0, stack_count_1, stack_count_2 := F, T, F;   // stack_count = 2
			else
				if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
					stack_count_0, stack_count_1, stack_count_2 := F, T, T;   // stack_count = 3
				else
					stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;


	/////////////////////////////////////////////////////////////////////////////////////////
	// Second loop thread
	/////////////////////////////////////////////////////////////////////////////////////////
		// While loop unroll 1
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop4_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop4;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop4_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop4: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
// While loop unroll 2
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop5_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop5;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop5_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop5: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
// While loop unroll 3
		if (F) then
			goto Exit_thread_while2;
		else
			// Inline Pop function
			// Unroll while in pop 1
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 2
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			// Unroll while in pop 3
			if (!(!stack_count_0 & stack_count_1)) then   // if (__VERIFIER_atomic_load(&stack.count) > 1)
				goto Exit_pop6_while1;
			else   // Enter while loop of Pop
				// int head1 := __VERIFIER_atomic_load(&stack.head);
				atomic, at := T, T;
				head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
				atomic, at := F, F;
				atomic, at := T, T;
				// int next1 := __VERIFIER_atomic_exchange(&stack.array[head1].Next, -1);
				if (!head1Pop_p) then
					if (*) then
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (*) then
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
						fi;
					fi;
				else   // head1 is a precise variable
					if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
						next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
					else
						if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
							next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
						else
							if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
								next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
								stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
							else
								// Out of bound so assign any arbitrary value
								if (*) then
									next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p;
									stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := T, T, T, T;   // stack_next := -1
								else
									if (*) then
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p;
										stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := T, T, T, T;
									else
										next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p := stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p;
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := T, T, T, T;
									fi;
								fi;
							fi;
						fi;
					fi;
				fi;
				atomic, at := F, F;

				if (!next1Pop_0) then    // if (next1 >:= 0)
					head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // head2 := head1
					atomic, at := T, T;
					// if (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head2, next1))
					if ((stack_head_p) & (head2Pop_p) & (stack_head_0 = head2Pop_0) & (stack_head_1 = head2Pop_1) & (stack_head_2 = head2Pop_2)) then
						stack_head_0, stack_head_1, stack_head_2, stack_head_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
						ifcond := T;
					else
						head2Pop_0, head2Pop_1, head2Pop_2, head2Pop_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
						ifcond := F;
					fi;
					atomic, at := F, F;
					if (ifcond) then
						//  __VERIFIER_atomic_fetch_sub(&stack.count, 1);
						atomic, at := T, T;
						if (!stack_count_p) then
							stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
						else
							if (!stack_count_0 & stack_count_1 & stack_count_2) then    // stack_count = 3
								stack_count_0, stack_count_1, stack_count_2 := F, T, F;
							else
								if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
									stack_count_0, stack_count_1, stack_count_2 := F, F, T;
								else
									if (!stack_count_0 & !stack_count_1 & stack_count_2) then   // stack_count = 1
										stack_count_0, stack_count_1, stack_count_2 := F, F, F;
									else
										stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
									fi;
								fi;
							fi;
						fi;
						atomic, at := F, F;
						elem_0, elem_1, elem_2, elem_p := head1Pop_0, head1Pop_1, head1Pop_2, head1Pop_p;   // return head1;
						goto EndPop6;
					else
						// __VERIFIER_atomic_exchange(&stack.array[head1].Next, next1);
						atomic, at := T, T;
						if (!head1Pop_p) then
							if (*) then
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (*) then
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								fi;
							fi;
						else   // head1 is a precise variable
							if (!head1Pop_0 & !head1Pop_1 & !head1Pop_2) then     // if head1 == 0
								stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
							else
								if (!head1Pop_0 & !head1Pop_1 & head1Pop_2) then  // if head1 == 1
									stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
								else
									if (!head1Pop_0 & head1Pop_1 & !head1Pop_2) then   // if head1 == 2
										stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
									else
										// Out of bound so assign any arbitrary value
										if (*) then
											stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;   // stack_next := -1
										else
											if (*) then
												stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											else
												stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := next1Pop_0, next1Pop_1, next1Pop_2, next1Pop_p;
											fi;
										fi;
									fi;
								fi;
							fi;
						fi;

						atomic, at := F, F;
					fi;
				fi;
			fi;
			assume(F);
			Exit_pop6_while1: skip;
			// End while loop of Pop
			elem_0, elem_1, elem_2, elem_p := T, T, T, T;      // Return -1
			EndPop6: skip;   // elem := Pop();

			if (!elem_0) then    // if elem >:= 0
				goto Exit_thread_while2;    // break while
			fi;
		fi;
	Exit_thread_while2: skip;

	atomic, at := T, T;
	// stack.array[elem].Value == 0;
	if (!elem_p) then
		if (*) then
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, T, F, T;
		else
			if (*) then
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, T, F, T;
			else
				stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, T, F, T;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then    // elem := 0
			stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, T, F, T;
		else
			if (!elem_0 & !elem_1 & elem_2) then   // elem := 1
				stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, T, F, T;
			else
				if (!elem_0 & elem_1 & !elem_2) then   // elem := 2
					stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, T, F, T;
				else
					if (*) then
						stack_value0_0, stack_value0_1, stack_value0_2, stack_value0_p := F, T, F, T;
					else
						if (*) then
							stack_value1_0, stack_value1_1, stack_value1_2, stack_value1_p := F, T, F, T;
						else
							stack_value2_0, stack_value2_1, stack_value2_2, stack_value2_p := F, T, F, T;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	///////////////////////////////////////
	///  ASSERTION
	///////////////////////////////////////
	// assert(stack.array[elem].Value == 0);
	if (!elem_p) then
		OF_ERROR: skip;
	else
		if (!elem_0 & !elem_1 & !elem_2) then
			if (!(!stack_value0_0 & stack_value0_1 & !stack_value0_2)) then
				SLIC_ERROR: skip;
			fi;
		else
			if (!elem_0 & !elem_1 & elem_2) then
				if (!(!stack_value1_0 & stack_value1_1 & !stack_value1_2)) then
					SLIC_ERROR: skip;
				fi;
			else
				if (!elem_0 & elem_1 & !elem_2) then
					if(!(!stack_value2_0 & stack_value2_1 & !stack_value2_2)) then
						SLIC_ERROR: skip;
					fi;
				else
					OF2_ERROR: skip;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;

	// Push(elem);
	atomic, at := T, T;
	// int head1 := __VERIFIER_atomic_load(&stack.head);
	head1Push_0, head1Push_1, head1Push_2, head1Push_p := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
	atomic, at := F, F;

	// Unroll dowhile 1
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	// Unroll dowhile 2
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	// Unroll dowhile 3
	atomic, at := T, T;
	// __VERIFIER_atomic_store(&stack.array[index].Next, head1);
	if (!elem_p) then
		if (*) then
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (*) then
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			fi;
		fi;
	else
		if (!elem_0 & !elem_1 & !elem_2) then     // elem := 0
			stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
		else
			if (!elem_0 & !elem_1 & elem_2) then    // elem := 1
				stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
			else
				if (!elem_0 & elem_1 & !elem_2) then    // elem := 2
					stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
				else
					if (*) then
						stack_next0_0, stack_next0_1, stack_next0_2, stack_next0_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
					else
						if (*) then
							stack_next1_0, stack_next1_1, stack_next1_2, stack_next1_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						else
							stack_next2_0, stack_next2_1, stack_next2_2, stack_next2_p := head1Push_0, head1Push_1, head1Push_2, head1Push_p;
						fi;
					fi;
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
	atomic, at := T, T;
	// (__VERIFIER_atomic_compare_and_exchange(&stack.head, &head1, index))
	if ((stack_head_p) & (head1Push_p) & (stack_head_0 = head1Push_0) & (stack_head_1 = head1Push_1) & (stack_head_2 = head1Push_2)) then
		stack_head_0, stack_head_1, stack_head_2, stack_head_p := elem_0, elem_1, elem_2, elem_p;
		ifcond := T;
	else
		head1Push_0, head1Push_1, head1Push_2, head1Push_2 := stack_head_0, stack_head_1, stack_head_2, stack_head_p;
		ifcond := F;
	fi;
	atomic, at := F, F;

	if (ifcond) then
		goto Exit_push2_dowhile;
	fi;

	assume(F);
	Exit_push2_dowhile: skip;

	atomic, at := T, T;
	// __VERIFIER_atomic_fetch_add(&stack.count, 1);
	if (!stack_count_p) then
		stack_count_0, stack_count_1, stack_count_2 := schoose[F,F], schoose[F,F], schoose[F,F];   // Any thing
	else
		if (!stack_count_0 & !stack_count_1 & !stack_count_2) then    // stack_count = 0
			stack_count_0, stack_count_1, stack_count_2 := F, F, T;  // stack_count = 1
		else
			if (!stack_count_0 & !stack_count_1 & stack_count_2) then  // stack_count = 1
				stack_count_0, stack_count_1, stack_count_2 := F, T, F;   // stack_count = 2
			else
				if (!stack_count_0 & stack_count_1 & !stack_count_2) then   // stack_count = 2
					stack_count_0, stack_count_1, stack_count_2 := F, T, T;   // stack_count = 3
				else
					stack_count_0, stack_count_1, stack_count_2, stack_count_p := schoose[F,F], schoose[F,F], schoose[F,F], F; // Any thing
				fi;
			fi;
		fi;
	fi;
	atomic, at := F, F;
end


